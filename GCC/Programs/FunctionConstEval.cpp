#include<iostream>

//consteval WAS INTRODCED IN C++20
//consteval FUNCTIONS GET EVALUATED AT COMPILE TIME, THE DIFFERENCE BETWEEN consteval AND constexpr IS THAT consteval THROWS A COMPILER ERROR IF THE FUNCTION CANNOT BE
//EVALUATED AT COMPILE TIME WHEREAS constexpr, EVEN THOUGH IT IS ALSO MEANT FOR COMPILE TIME EVALUATIONS OF FUNCTIONS, THERE IS NO COMPILE TIME ERROR EVEN WHEN THERE IS
//NO POSSIBILITY OF A constexpr FUNCTION EVALUATING AT COMPILE TIME, IT SILENTLY FAILS
//consteval ENFORCES A FUNCTION TO BE EVALUATED AT COMPILE TIME, ELSE IT THROWS ERROR

consteval int mutiplier(int value){                     //FOR constexpr AND consteval FUNCTIONS, SPLITTING OF A FUNCTION INTO PROTOTYPE AND DEFINITION WILL NOT WORK
    return value * 100;
}

int main(int argc, char **argv){

    //consteval int val1 {100};                         //COMPILER ERROR consteval CANNOT BE USED FOR DECLARING VARIABLES OR STATIC DATA MEMBERS
    std::cout << "Calling multiplier()" << std::endl;
    int res1 = mutiplier(100);                          //THIS consteval FUNCTION CALL WORKS BECAUSE WE ARE PASSING A LIERAL AS PARAM / ARGS
    std::cout << "Result is: " << res1 << std::endl;
    int val3 {100};
    //COMPILER ERROR => AS IS THE NATURE OF consteval THIS consteval FUNCTION CALL FAILS BECAUSE IT IS NOT ABLE TO ASCERTAIN THE VALUE OF ITS PARAM / ARGS AS ITS VALUE CAN
    //ONLY BE ASCERTAINED ONLY DURING RUNTIME, WHICH IS AGAINST consteval DESIGN WHICH REQUIRES ALL ITS FUNCTION, PARAMS / ARGS AND ALSO ITS LOCAL VARIABLES WHICH CAPTURE
    //A consteval FUNCTION'S RESULT ALSO TO BE ASCERTIANED DURING COMPILE TIME
    //int res2 = mutiplier(val3); 
    return 0;
}