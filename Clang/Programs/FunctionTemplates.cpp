#include<iostream>
#include<string>

//Function Templates are used where there are multiple overloads of a single function. When we need to overload a function many times (like > 10), function templates are
//are used, as they basically reduce code repetition. Function templates are somewhat similar in behaviour to function overloading.
//Function templates provide a blueprint for a function implementation and the compiler will provide the appropriate function body when that function is called.
//Function Templates syntax:
/*
template<typename T>
T <<template_name>>(T <params>, T <params>, T <params>.....n){
    <function template body>
}
*/

//NOTE: FUNCTION TEMPLATES ARE NOT REAL C++ CODE, THEY ARE JUST PLACEHOLDERS/BLUEPRINTS FOR THE ACTUAL CODE WHICH WILL BE GENERATED BY THE COMPILER DURING RUNTIME AS PER
//PARAMS / ARGS PASSED
//TO ACTUALLY SEE THE FUNCTION TEMPLATES BEING GENERATED DURING RUNTIME, VISIT: https://cppinsights.io/ AND RUN THE FUNCTION TEMPLATE CODE
//ONE MORE WAY CHECK THE GENERATION OF ACTUAL FUNCTIONS DURING RUNTIME IS TO USE DEBUGGER => WHEN BREAKPOINTS ARE SET APPROPRATELY AND FUNCTION TEMPLATES ARE EXECUTED,
//WE CAN ACTUALLY SEE THE ACTUAL FUNCTIONS WITH ACTUAL PARAMS / ARGS TYPES BEING PUSHED INTO FUNCTION CALL STACK

template<typename T>
T maximum(T a, T b);                                        //function template declaration=>T is a placeholder for our type max is he template name, a and b are params/args

template<typename T>                                        //function template declaration=>T is a placeholder for our type max is he template name, a and b are params/args
T multi(T a, T b);

int main(int argc, char **argv){

    int a {100};                                            //int type
    int b {200};                                            //int type

    int *p_a {&a};                                          //int pointer type
    int *p_b {&b};                                          //int pointer type

    double c {10.99};                                       //double type
    double d {20.99};                                       //double type

    std::string e {"Hello "};                               //std::string type
    std::string f {"Mars"};                                 //std::string type

    std::cout << "max(): " << maximum(a, b) << std::endl;   //calling max() for int types => correct result
    std::cout << "max(): " << maximum(c, d) << std::endl;   //calling max() for double types => correct result
    std::cout << "max(): " << maximum(e, f) << std::endl;   //calling max() for std::string types => LEXICOGRAPHICALLY CORRECT
    //BE VERY CAREFUL PREVIOUSLY maximum(std::string, std::string) WAS NAMED max(std::string, std::string) BUT max(std::string, std::string) IS ALREADY EXISTING ELSEWHERE,
    //HENCE GAVE RISE TO COMPILER ERROR => SO NAME CHANGED TO max(std::string, std::string)

    std::cout << "multi(): " << multi(a, b) << std::endl;   //calling multi() for int types => correct result
    std::cout << "multi(): " << multi(c, d) << std::endl;   //calling multi() for double types => correct result
    //std::cout << "mutli(): " << multi(e, f) << std::endl;   //COMPILER ERROR => calling multi() for std::string types => std::string IS NOT COMPATIBLE WITH * OPERATOR

    //CALLING maximum() WITH DIFFERENT PARAMS / ARGS TYPE:
    //std::cout << "max(): " << maximum(a, c) << std::endl;   //COMPILER ERROR => THIS IS BECAUSE WHEN WE DECLARED AND DEFINED THE maximum() TEMPLATE, WE FORCED IT TO USE
    //THE SAME TYPE T AS THE PARMS / ARGS, SO THE COMPILER EXPECTS SAME TYPE OF PARAMS / ARGS TO BE PASSED AND WHEN WE PASS PARAMS / ARGS OF DIFFERENT TYPES, IT
    //RESULTS IN A COMPILER ERROR

    //USING TEMPLATES WITH POINTERS:
    std::cout << "max(): " << maximum(p_a, p_b) << std::endl;//calling max() with pointers as params / args => pointer comparison => address comparison => gives the output
    //but compares the ponters' ADDRESSES instead of their respective values => which gives undesired results.

    //GIVES CORRECT OUTPUR WHEN DEREFERENCED POINTERS ARE USED (OBVIOUSLY) 
    std::cout << "max(): " << maximum(*p_a, *p_b) << std::endl;

    return 0;

}

template<typename T>                                        //FUNCTION TEMPLATE DEFINTION
T maximum(T a, T b){
    return (a > b)? a : b;
}

template<typename T>                                        //FUNCTION TEMPLATE DEFINTION
T multi(T a, T b){
    return a * b;
}